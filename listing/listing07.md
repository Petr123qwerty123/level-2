Что выведет программа? Объяснить вывод программы.

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func asChan(vs ...int) <-chan int {
	c := make(chan int)

	go func() {
		for _, v := range vs {
			c <- v
			time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
		}

		close(c)
	}()
	
	return c
}

func merge(a, b <-chan int) <-chan int {
	c := make(chan int)
	
	go func() {
		for {
			select {
			case v := <-a:
				c <- v
			case v := <-b:
				c <- v
			}
		}
	}()
	
	return c
}

func main() {
	a := asChan(1, 3, 5, 7)
	b := asChan(2, 4, 6, 8)
	
	c := merge(a, b)
	
	for v := range c {
		fmt.Println(v)
	}
}
```

**Ответ:**

Вывод: числа от 1 до 8 в рандомном порядке и нули.

### Описание работы функции `asChan`
В функции `asChan` с помощью spread operator (...) мы собираем переданные аргументы функции в слайс `vs` типа `[]int`. 
Создаем канал `c` типа `chan int`, запускаем анонимную горутину и возвращаем созданный канал в режиме чтения (тип
возвращаемого значения - `<-chan int`).

#### Описание работы анонимной горутины в функции `asChan`
В анонимной горутине мы циклом записываем в канал переданные в слайс `vs` аргументы функции. После отправки данных в 
канал горутина засыпает на рандомное количество миллисекунд (границы рандома - [0, 1000)). Так как канал 
небуферизированный, то на следующей итерации цикла горутина блокируется до получения предыдущих данных 
горутиной-получателем. После завершения работы цикла, канал закрывается, чем и заканчивается работа горутины.

### Описание работы функции `merge`
В функции merge мы в качестве агрументов принимаем два канала в режиме чтения - `a`, `b`. Создаем канал `c` типа 
`chan int`, запускаем анонимную горутину и возвращаем созданный канал в режиме чтения (тип возвращаемого значения - 
`<-chan int`).

#### Описание работы анонимной горутины в функции `merge`
В анонимной горутине мы бесконечным циклом проходимся по конструкции `select - case`. `select` блокируется до тех пор, 
пока один из его блоков `case` не будет готов к запуску, а затем выполняет этот блок. Если сразу несколько блоков могут 
быть запущены, то выбирается произвольный. В случае разблокировки хотя бы одного из блоков, мы получаем данные из 
канала (`a` или `b`), кладем полученные данные в переменную `v` и записываем их в созданный в функции `merge` канал `c`.

### Описание работы функции `main`
Создаем два канала - `a` и `b` - в режиме чтения с помощью функции `asChan`. С помощью функции `merge` мы объединяем 
получение данных в один канал `c` и с помощью цикла читаем данные и выводим их на экран. Так как в функции `asChan` 
каналы закрываются, то после закрытия хотя бы одного из каналов будем получать нули в объединенный канал c, а так как 
цикл в функции `merge` бесконечный, а также объединенный канал мы нигде не закрываем, то нули в объединенный канал мы 
будем получать бесконечно, пока не остановим программу.